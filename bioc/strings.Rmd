---
title: "Working with DNA sequences using Biostrings"
author: "[Michael Love](http://mikelove.github.io)"
output: html_document
---

In this last section, we combine what we learned about
[ranges](ranges.html) and [annotation](anno.html) in order to obtain
sequences of DNA from a genome.

First we introduce the Bioconductor package that we use to manipulate
DNA strings (also RNA strings or amino acid strings). First, I load
the package, and create a short character string with some letters of
DNA: 

```{r echo=FALSE}
knitr::opts_chunk$set(cache=TRUE)
```

```{r message=FALSE}
library(Biostrings)
dna <- "AAACGCG"
class(dna)
```

A simple character string in R doesn't help us much for working with
DNA. We can `subset` out parts of it using base R, but there's a not
of functionality missing. Note what we can do once we turn it into a
*DNAString* object. The reverse complement of a string is the letters
you would see on the antisense strand of DNA, going from right to
left. This is a useful function; for example, if we have a gene that
is transcribed on the - strand, the RNA that is produced will be the
reverse complement of the DNA on the + strand (this is the DNA that
you see in the *reference genome*, which we will load later).

```{r}
dna <- DNAString("AAACGCG")
reverseComplement(dna)
```

A *DNAStringSet* is a vector of DNAStrings. If we want to know how
many strings, we use `length`, whereas if we want to know how many
letters per DNAString, we use `width`:

```{r}
dna <- DNAStringSet(c("AAAAA","CGCG","TCG"))
dna
length(dna)
width(dna)
```

There are a number of functions in the Biostrings package to help
quickly tabulate things like letter frequency in the strings:

```{r}
letterFrequency(dna, "C")
letterFrequency(dna, "C", as.prob=TRUE)
letterFrequency(dna, "CG", as.prob=TRUE)
```

We can also look for matches of a query in a set of strings, using the
function `vmatchPattern`.
The `elementNROWS` function lets us know how many matches were found
per string in `dna`. And then we can see where the matches begin and
end by looking into individual elements. Note that the matches are
described as `IRanges`.

```{r}
dna <- DNAStringSet(c("AACTCTC","CTCTAAA","AAAGAG"))
matches <- vmatchPattern("CTC", dna)
elementNROWS(matches)
matches[[1]]
```

The opposite setup: we can look for a set of queries within a longer
string, using `matchPDict`. These function may sound like they have funny
names but the names often have to do with the data structures or
algorithms used to quickly compute the matches.

```{r}
dna <- DNAString("AAACTCAAAGAGAAATTTAAA")
pd <- PDict(c("CTC","GAG","TTT","AAA"))
matches <- matchPDict(pd, dna)
elementNROWS(matches)
matches[[4]]
```

# Working with genomes

Many genomes exist as packages on Bioconductor, for example:

* [BSgenome.Hsapiens.UCSC.hg19](http://bioconductor.org/packages/BSgenome.Hsapiens.UCSC.hg19)
* [BSgenome.Hsapiens.UCSC.hg38](http://bioconductor.org/packages/BSgenome.Hsapiens.UCSC.hg38)
* [BSgenome.Hsapiens.NCBI.GRCh38](http://bioconductor.org/packages/BSgenome.Hsapiens.NCBI.GRCh38)

We will work with the UCSC version of the hg38/GRCh38 genome, the
second package above. This package is ~670 Mb, so you may want to keep
track of where it is kept on your computer. You can look up the
library path using `.libPaths()`, and you can remove packages with
`remove.packages()`.

But first, I want to show you also how to work with genomes that don't
exist as a package on Bioconductor. The first step would be to load up
the *AnnotationHub* package:

```{r results="hide"}
library(AnnotationHub)
ah <- AnnotationHub()
```

As before, you can look through a web browser to find a particular genome.
For example, try searching for **species:** Homo sapiens, **genome:** grch38,
**description:** FASTA.
Notice the different descriptions. Note that "cDNA" stands for the
sequence that is transcribed into RNA (so the exon sequence of
transcripts).

```{r, eval=FALSE}
display(ah)
```

We can also query the AnnotationHub using the `query` function. 
Suppose we wanted the GRCh38 human genome (though we have it above in a
package). We look for the files labeled `dna.primary_assembly`:

```{r}
res <- query(ah, c("ensembl","GRCh38","dna.primary_assembly"))
res$sourceurl
```

We could then download one of these files using double square
brackets, to pick which of the genomes in `res`. We won't do that.
Instead, we will work with the package described above, which can be
downloaded with `biocLite()`

```{r}
library(BSgenome.Hsapiens.UCSC.hg38)
Hsapiens
```

We can extract particular sequences from a reference genome using
*GRanges*. Note that the difference between the "UCSC" and
"NCBI/Ensembl" style of chromosomes is `chr1` vs `1`.

```{r}
seqinfo(Hsapiens)
gr <- GRanges("chr1", IRanges(1e6 + c(1,101,201), width=100))
gr
dna <- getSeq(Hsapiens, gr)
dna
```

# Working with a transcriptome

We can download the cDNA ("complementary DNA"), which is the sequence
of the exons for each transcript. Note that, if the gene is on the -
strand, then the cDNA will be the reverse complement of the reference
genome, the `Hsapiens` object above.

```{r}
txome <- query(ah, c("ensembl","GRCh38","cdna.all","release-87"))[[1]]
```

The `seqnames` in this case are not the chromosomes, they are the
names of the transcripts, and there are 178,000 of them. Note that the
transcript names have a `.` and an extra number on the end. We will
have to chop this extra number off later.

```{r}
seqinfo(txome)
txs <- seqnames(seqinfo(txome))
head(txs)
```

In order to extra a transcript's sequence, we use the transcript name
and we need to know the length of the transcript. We pick a transcript
at random.

```{r}
si <- seqinfo(txome)
idx <- 5000
tx.name <- seqnames(si)[idx]
tx.name
tx.len <- seqlengths(si)[idx]
tx.len
tx.seq <- getSeq(txome, GRanges(seqnames(si)[idx], IRanges(1, tx.len)))
tx.seq
```
