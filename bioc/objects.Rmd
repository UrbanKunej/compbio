---
title: "Working with Bioconductor objects"
author: "[Michael Love](http://mikelove.github.io)"
output: rmarkdown::html_document
---

Why use Bioconductor? From a user perspective, the answer is clear:
because many statisticians, bioinformaticians, and computer scientists
have spent time writing methods and algorithms specifically for
biological (often genomic) data. A reason for this (why many people
have contributed to this project) is that there is a shared
infrastructure for common data types. This infrastructure is built up
of object classes. An example of a class is *GRanges* which is a way
to specify a set of ranges in a particular genome, e.g. from basepair
100 to basepair 200 on chromosome 1 of the human genome (version 38).

We will introduce the different Bioconductor objects in this
section. In this particular document, we will discuss perhaps the most
important class of object, which is the *ExpressionSet* or
*SummarizedExperiment* (it's actually two classes, I lied). But they
are similar so I will present them together. They have the same
structure:

* a matrix of data, rows are genomic features, and columns are samples
* a table of data about the samples (columns)
* a table of data about the features (rows)

A diagram of this 3-part structure can be found 
[here](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4509590/figure/F2/).

The ExpressionSet was created primarily to store *microarray* data,
where each column of the matrix stored the values from a particular
microarray. The SummarizedExperiment is a new class, similar to
ExpressionSet, which makes more sense for the era of *sequencing*
data. One particular difference is that the rows of a
SummarizedExperiment can correspond to particular *GRanges*, e.g. the
number of RNA-seq reads that can be assigned to a particular gene, and
the location of the gene in the genome.

But first let's explore the ExpressionSet, because it came first in
time, and it's very simple:

```{r message=FALSE}
library(Biobase)
phenoData <- data.frame(sample=factor(1:6),
                        condition=factor(c("A","A","B","B","C","C")),
                        treated=factor(rep(0:1,3)))
phenoData
```

```{r}
featureData <- data.frame(geneID=1:10, geneSymbol=letters[1:10])
featureData
```

```{r}
exprs <- matrix(rnorm(6 * 10), ncol=6, nrow=10)
eset <- ExpressionSet(exprs,
                      AnnotatedDataFrame(phenoData),
                      AnnotatedDataFrame(featureData))
eset
```

```{r}
pData(eset)
fData(eset)
```

```{r}
idx <- eset$condition %in% c("A","B")
eset.sub <- eset[,idx]
pData(eset.sub)
```

```{r}
levels(eset.sub$condition)
```

```{r}
library(magrittr)
eset.sub$condition %<>% droplevels
levels(eset.sub$condition)
```

```{r}
exprs(eset.sub)
exprs(eset)[,idx]
```

# GEO

2 million samples are hosted by the 
Gene Expression Omnibus, or [GEO](https://www.ncbi.nlm.nih.gov/geo/).

```{r message=FALSE}
library(GEOquery)
geo <- getGEO("GSE2125")
names(geo)
e <- geo[[1]]
```

```{r}
names(pData(e))
e$condition <- sub("status: ","",e$characteristics_ch1)
table(e$condition)
```

```{r}
exprs(e)[1:5,1:5]
boxplot(exprs(e),range=0)
```

```{r}
library(preprocessCore)
exprs(e) <- normalize.quantiles(exprs(e))
boxplot(exprs(e),range=0)
```

```{r message=FALSE}
library(matrixStats)
rv <- rowVars(exprs(e))
```

```{r}
library(pheatmap)
o <- head(order(rv, decreasing=TRUE),200)
pheatmap(exprs(e)[o,],
         annotation_col=pData(e)["condition"],
         show_rownames=FALSE, show_colnames=FALSE)
```

